============================0712======================


========================Remind=======================

* 클래스-----------------------------------------------

# -----------------------------------------------------------
# 클래스
#       - 객체지향언어에서(OOP)에서 데이터를 정의하는 자료형
#       - 데이터를 정의할 수 있는 데이터의 속성 & 기능 명시
# 
#       - 구성요소:
#               속성(attribute/field) + 기능(method)

#       - 클래스를 생성해도 바로 메모리 힙 영역에 클래스 자체가 할당되지는 않음 
#       - 클래스 바탕 객체를 생성해야 해당 객체가 힙 영역에 할당됨
# -----------------------------------------------------------


* 판다스 ------------------------------------------------

- Dict이 Key가 Columns로 저장!

- 속성으로 행 Index 변경 -> 변수명.index = 새로운 index

- 속성으로 열 Index 변경 -> 변수명.columns = 새로운 columns

- [열/컬럼 선택]:       변수명[컬럼명/컬럼인덱스] /  변수명.컬럼명

- [행/row 선택]:       변수명.iloc[행인덱스] / 변수명.loc[행인덱스]

					- iloc ==> int + loc의 준말 ==> 오직 정수 인덱스만 가능!!
					-  loc ==> 정수가 아닌 행인덱스 가능!!
					# 여러 개 행 추출
								df1.loc[ [row_1, row_2]]

					# 권장 방법
					- 변수명.iloc[정수_인덱스][열인덱스] 
					- 변수명.loc[열인덱스]



	##원소/요소 추출----------------------------------------------
1) 인덱싱
		- 변수명.iloc[정수_인덱스, 정수_인덱스]
		- 변수명.loc[행_인덱스, 열_인덱스]

2) 슬라이싱
		- 변수명.iloc[정수_인덱스, 정수_인덱스:정수_인덱스]
		- 변수명.loc[행_인덱스, 열_인덱스:열_인덱스]


	## DataFrame 행/열 인덱스 변경----------------------------------
- method_1) 속성명으로 변경 ==> 전체 변경

- method_2) 메서드명으로 변경 ==> 일부 변경    
				(원본 데이터 변경 X, 출력만!!, inplace_옵션으로 원본 변경 O)

				예시)
					## [실습] 행 인덱스 일부 변경:  P2 ==> END 로 변경
					dataDF.rename(index={'P2':'END'}, inplace=True)

- inplace 매개변수
				True -> 복사본 X -> 원본 데이터 변경
				False -> 복사본 O -> 원본 데이터 영향 X

	## DataFrame 행/열 삭제

    * 행 삭제: DF_변수명.drop()		==>원본 변경 X
    * 열 삭제: DF_변수명.drop(       , axis=1, axis='columns') 	==> 원본 변경 O

    * 변수명.drop(index): 지정된 인덱스의 행 삭제
    * 변수명.drop(columns): 지정된 인덱스의 열 삭제

	## DataFrame 행/열 인덱스 츄가----------------------------------

  * 행 추가: DF_변수명.loc[ '추가할 행 이름'] = 열 개수와 같은 길이의 데이터 리스트/튜플         
						
														==>		iloc는 불가!!

  *      1개 행 추가 w/ 데이터 수 1개   --> 모든 컬럼에 동일 값 저장

  * 열 추가: DF_변수명.[ '추가할 열 이름'] = 행 개수와 같은 길이의 데이터 리스트/튜플

  *      1개 열 추가 w/ 데이터 수 1개   --> 모든 행에 동일 값 저장






=========================EXAM======================
====================================================

[순수 프로그래밍]
	--> 원시데이터 타입 (int float bool : Primitive)
	--> 컬렉션데이터 타입 (list tuple dic set  : collection)


[데이터 분석 프로그램]
	--> 파이썬 언어를 사용한 판다스!



## 클래스 생성------------------------------------------------

# 클래스 정의:  햄버거를 나타내는 클래스
# 클래스 이름:  Bugger
# 클래스 속성:  번, 패티, 야채, 치즈(옵션), 브랜드
# 클래스 기능:  햄버거 설명 기능
# -----------------------------------------------------------


class Bugger:

    # 힙 영역에 객체 생성 시, 속성값 저장 기능
    def __init__(self, bread, patty, veg, kind):  
        
        self.bread=bread
        self.patty=patty
        self.veg  =veg

        self.kind =kind

    # 클래스 기능 선언(method)
    def printInfo(self):            # 'self'에는 객체 주소가 할당됨

        print(f'브 랜 드:    {self.kind}')
        print(f'빵 종류:    {self.bread}')
        print(f'패   티:    {self.patty}')
        print(f'야   채:    {self.veg}')



# Bugger 객체 생성---------------------------------------------

# bugger1 = Bugger()

'''
TypeError: __init__() missing 4 required positional arguments: 'bread', 'patty', 'veg', and 'kind'

Bugger 클래스 내 선언한 함수 __init__ 읽음!
'''

# 불고기 버거 객체생성
bugger1 = Bugger('브리오슈', '불고기','양상추 양파 토마토','롯데리아')

bugger2 = Bugger('참깨곡물', '쇠고기패티', '치즈 양상추 양파 토마토', '맥도널드')



# 버거 정보 확인
bugger1.printInfo()
'''
브 랜 드:    롯데리아
빵 종류:    브리오슈
패   티:    불고기
야   채:    양상추 양파 토마토
'''

bugger2.printInfo()
'''
브 랜 드:    맥도널드
빵 종류:    참깨곡물
패   티:    쇠고기패티
야   채:    치즈 양상추 양파 토마토
'''

## 모든 Bugger 클래스에 대해 브랜드가 똑같을 때!!!!!!!!!!!


class Bugger:

    kind = "맥도널드"           # 모든 버거가 롯데리아일 때, 선언
                              		  #  이제 kind는 클래스 속성!!!! (모든 bugger 클래스에서 공통된 속성이니까)



    # 힙 영역에 객체 생성 시, 속성값 저장 기능
    def __init__(self, bread, patty, veg):  
        
        self.bread=bread            # bread,patty,veg는 클래스 선언 시 마다 상이함
        self.patty=patty           			 #       --> 인스턴스 속성!!!!
        self.veg  =veg

        # self.kind =kind


    # 클래스 기능 선언(method)
    def printInfo(self):            # 'self'에는 해당클래스에서 선언한 버거 인스턴스 주소가 할당됨

        print(f'브 랜 드:    {self.kind}')
        print(f'빵 종류:    {self.bread}')
        print(f'패   티:    {self.patty}')
        print(f'야   채:    {self.veg}')



# kind 속성 선언 안함!!!!!
bugger1 = Bugger('브리오슈', '불고기','양상추 양파 토마토')
bugger2 = Bugger('참깨곡물', '쇠고기패티', '치즈 양상추 양파 토마토')

# 버거 정보 확인
bugger1.printInfo()
'''
브 랜 드:    맥도널드
빵 종류:    브리오슈
패   티:    불고기
야   채:    양상추 양파 토마토
'''

bugger2.printInfo()
'''
브 랜 드:    맥도널드
빵 종류:    참깨곡물
패   티:    쇠고기패티
야   채:    치즈 양상추 양파 토마토
'''


#### DataFrame----------------------------------------------------
- 판다스에서 데이터를 저장하는 2차원 자료형
- 구성: 2차원 데이터 (행&열)  /  Index + 열이름 + 데이터
- 형식: pandas.DataFrame( 2D_데이터 )


## DF 속성 읽기
			- index, columns, values, ndim, dtypes


- 속성으로 행 Index 변경 -> 변수명.index = 새로운 index

- 속성으로 열 Index 변경 -> 변수명.columns = 새로운 columns




































	


