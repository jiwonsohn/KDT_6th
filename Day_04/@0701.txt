============================0701======================


========================Remind=======================

* 타입 변경 --> 형변환, 타입캐스팅, 캐스팅

* 튜플
	-> (10, ) or 10,

* 원소들이 순서가 있고 반복가능한 데이터 타입 -> 시퀀스 데이터 타입
	- 슬라이싱, 인덱싱, 인덱스

	- 리스트 (수정 O)
	- 튜플, 문자열 (수정 X)

* 반복가능한 데이터 타입
	- 시퀀스 데이터 타입 포함
	- 내부 next() 함수를 이용해서 다음 순번의 순서들 추출 가능


* range()	: 수의 범위를 생성하는 내장함수

	- range(시작숫자, 끝숫자 +1, 간격)

	
* 클래스
	- 32명의 학생 정보 저장
		-> 하나의 정보 카테고리에 대해 총 32개의 변수가 필요하다면 메모리 소요가 큼
		-> 메모리 할당을 적게 하는 방향으로 효율적 데이터 저장을 위해 객체 + 함수(메서드) 등을 포함한 새로운 데이터 타입(ex. student 클래스) 선언하는 것이 클래스

		-> C에서 사용하는 구조체에서 기반



=========================EXAM======================

# -------------------------------------------------
# Dict 자료형
# - 여러가지 데이터를 dict 타입으로 저장
# -------------------------------------------------



## [다양한 종류의 키]--------------------------------
## - 키가 여러 개 정보를 합쳐서 사용하는 경우
## - 튜플 형태로 키 선언!! (키가 수정 불가능케 만들기 위해)

# 홍길동 1996년생, 홍길동 2000년생
person ={'age':20, ['홍길동', 2000]:100}
'''
TypeError: unhashable type: 'list'

키는 변경 불가능 타입이기 때문에 리스트로 선언 불가능
'''


## [실습] 중복되는 정보를 가진 4명 정보 저장
p1 = {'name':'홍길동', 'age':20,    'job':'학생'}
p2 = {'name':'마징가', 'age':100,   'job':'영웅'}
p3 = {'name':'배트맨', 'age':98,    'job':'박쥐'}
p4 = {'name':'홍길동', 'age':11,    'job':'학생'}


# 유일하게 서로 다른 데이터만을 담은 'age' 를 키로 선언!!

persons2 = {20: {'name':'홍길동','job':'학생'},
            100: {'name':'마징가', 'job':'영웅'},
            98: {'name':'배트맨', 'job':'박쥐'},
            11: {'name':'홍길동', 'job':'학생'} }



# 키에 2개 이상의 정보를 튜플로 선언 & 저장
persons3 = { ('홍길동',20)  : {'job':'학생'},
             ('마징가',100) : {'job':'영웅'},
             ('배트맨', 98) : {'job':'박쥐'},
             ('홍길동', 11) : {'job':'학생'}}

# 접근!
print( persons3[('홍길동', 11)])

# -------------------------------------------------
# Dict 자료형
# - dict 자료형 전용 함수, 메서드
# - 사용법: 변수명.메서드()
# -------------------------------------------------


## keys() - dict에서 키만 추출하는 메서드

p1 = {'name':'홍길동', 'age':20,    'job':'학생'}


result = p1.keys()
print(f'key 추출        -> {result}')
print(f'추출 데이터 타입 -> {type(result)}')

'''
key 추출        					-> dict_keys(['name', 'age', 'job'])
추출 데이터 타입 				-> <class 'dict_keys'> -> not list!!
'''

	-> 데이터가 많을 때, 키 접근 : for 구문으로 접근!!


## values() - dict에서 값만 추출하는 메서드
result = p1.values()

print(f'값 추출         -> {result}')
print(f'추출 데이터 타입 -> {type(result)}')

'''
값 추출         -> dict_values(['홍 길동', 20, '학생'])
추출 데이터 타입 -> <class 'dict_values'>
'''

## items() - dict에서 키&값을 튜플로 묶어서 추출하는 메서드
result = p1.items()

print(f'items()         -> {result}')
print(f'추출 데이터 타입 -> {type(result)}')

'''
items()         -> dict_items([('name', '홍길동'), ('age', 20), ('job', '학생')])
추출 데이터 타입 -> <class 'dict_items'>
'''

# items() 추출!!
result = list(result)
print(f'키와 값 튜플 추출: { result[0] }, {type(result[0])}')

'''
키와 값 튜플 추출: ('name', '홍길동'), <class 'tuple'>
'''


# -------------------------------------------------
# Dict 자료형
# - 연산자와 dict 자료형
# -------------------------------------------------

person = {'name':'홍길동', 'age':20,    'job':'학생'}
doggy = {'species':'perg', 'weight':4.5, 'color':'blue','gender':'F','age':3}

## [연산자] ---------------------------------------

# 산술 연산 불가능
# person + doggy

# 멤버 연산자: in, not in 가능
# dict에선는 key만 멤버 연산자 연산 가능

# value 추출 w/ values()
print('perg' in doggy.values())
print( 20 in person.values())

## [내장함수] --------------------------------------------

## - len(): 원소/요소 개수 확인


## - sorted():  원소/요소 정렬 / key만 정렬
## 단, 모든 keys 데이터 타입이 서로 동일해야!


## 키와 값을 따로 정렬하면,
키 정렬 순서 != 값 정렬 순서 이기 때문에 (키-값) 묶음으로서의 성질을 잃어버릴 수 있음



## 따라서, items()로 키&값 함께 추출!!
## items()

print(f'jumsu 키 오름차순 정렬: {sorted(jumsu.items() )}')
'''
jumsu 키 오름차순 정렬: [('국어', 90), ('수학', 178), ('체육', 100)]

	-> items() 결과 튜플의 0th 원소 (국어, 수학,체육) 기준으로 정렬한 것!

	-> 점수 값으로 정렬하기 위해서는 1th 원소로 정렬 기준 재설정!!	w/ lambda !!
'''

print(f'jumsu 키 오름차순 정렬: {sorted(jumsu.items() , key= lambda x:x[1])}')









	


