============================0628======================


* input()
	- input 함수 출력값은 무조건 '문자열'
	- 1개의 문자열로 출력 ex) '10 20 30' 

	- .split()로 ()안 구분자 기준으로 입력값 분리 가능
		예시) 
		# 1개 문자열 -> 구분자 기준으로 문자열 분리
		print("data.split()->", data.split())
		'''
		data.split()-> ['10', '20', '30']
		'''

* map()
	- map( 사용할 함수명, multiple 데이터 )
	
	- 함수명을 변수에 담아 선언해도 가능
	예시)
	
# 사용할 함수 변수로 선언
myfunc=int
result2 = map(myfunc, nums)
print(type(result2), result2)
'''
<class 'map'> <map object at 0x000002A234A01F40>
'''


#-----------------------------------------------------------------
# 연산자 - 객체비교연산자
#       힙 영역에 존재하는 데이터, 즉 저장된 데이터 클래스 기반으로
#       2개 변수가 동일한 객체를 저장하고 있는지 확인
#-----------------------------------------------------------------

* 객체비교 != 비교연산
	- 객체비교 -> 변수가 저장하고 있는 객체 주소 비교
	- 비교연산 -> 변수의 값을 비교



# indexing: 문자열에서 문자 1개를 식별하는 방법
#       - 원소/요소: 문자열 안에 문자 1개
#       - 사용법: 변수명[인덱스]
#       - 인덱스 종류
#       * 왼 >>> 오 : 0,1,2,...
#       * 왼 <<< 오 : ....,-2,-1

# Slicing: 문자열에서 연속된 요소/원소 추출 방법
#       - 원소/요소: 문자열 안에 문자 1개
#       - 사용법: 변수명[시작:끝+1] 시작인덱스 이상 ~ 끝인덱스 미만

# Slicing: 문자열에서 규칙/패턴을 가진 요소/원소 추출 방법
#       - 사용법: 변수명[시작:끝+1:간격] 



#-----------------------------------------------------------------
# 문자열 str 데이터 다루기
#   - 문자열 원소/요소 변경 체크
#   - 원소/요소 단위 변경 즉, 수정과 삭제 불가
#   - 산술연산자 중 (+) -> 하나의 문자열로 열결
#   - 산술연산자 중 (*) -> 정수만큼 문자열 반복 & 1개 문자열로 연결
#   - 멤버 연산자 in, not in
#   - 내장함수 len(), ord(문자 1개), chr(코드 1개)
#-----------------------------------------------------------------


#-----------------------------------------------------------------
# 문자열 str 데이터 다루기
#   - 이스케이프문자: 특수한 의미를 가진 문자
#       * 형식: \{문자 1개}
#       * 종류:
#           '\n', '\t', '\''('), '\"'("), 
#           '\\'(\, path or URL 관련), '\U'(유니코드)
#-----------------------------------------------------------------

# Raw string -> 경로, 문자열 처리에 자주!!
# r'  ' or R'   ' : 문자열 내 이스케이프 문자 무시!
file = r'C:\Users\KDP-43\Downloads\test.txt'
print(file)
'''
C:\Users\KDP-43\Downloads\test.txt
'''

# 원래는 \U \t를 이스케이프 문자로 읽어 오류남
'''
SyntaxError: (unicode error) 'unicodeescape' codec can't decode bytes in position 2-3: truncated \UXXXXXXXX escape
'''
'''

#-----------------------------------------------------------------
# List data 자료형 살펴보기
# - 원소/요소 변경  -> w.m) 데이터 변경, 삭제
#-----------------------------------------------------------------

# 0번 ~ 2번원소를 22,33,44,55,66,77,88 변경
# datas=[100, 9, 11]
datas[:3] = [22,33,44,55,66,77,88]		
print(datas)
'''
[22, 33, 44, 55, 66, 77, 88]
'''

# 시퀀스[:: step] -> step=1이면 원소 대입 가능
			    -> step 1보다 크면 길이(len) 맞춰야 대입 가능
 
datas[::1]	-> 연속적인 시퀀스 형태
datas[::2]	-> 비연속적

#-----------------------------------------------------------------
# List data 자료형 살펴보기
# - 리스트 & 메모리
# - 리스트는 요소/원소 객체의 주소를 저장
# - 따라서, 같은 객체를 저장하는 경우 메모리주소가 같음
# - 단, 리스트 자체 주소는 서로 다름
#-----------------------------------------------------------------


nums = [10,20]
num2 = list([10,20])

print(f'nums id: {id(nums)}')
print(f'nums[0] id: {id(nums[0])}')     #10
print(f'nums[1] id: {id(nums[1])}')     #20
print("*"*20)

print(f'num2 id: {id(num2)}')
print(f'num2[0] id: {id(num2[0])}')     #10
print(f'num2[1] id: {id(num2[1])}')     #20
'''
nums id: 2655008204224
nums[0] id: 2655006190160
nums[1] id: 2655006190480
********************
num2 id: 2655008512384
num2[0] id: 2655006190160
num2[1] id: 2655006190480


nums[0] id: 2655006190160 == num2[0] id: 2655006190160
nums[1] id: 2655006190480 == num2[1] id: 2655006190480
'''

* 리스트 자체 주소는 서로 다름!!
nums = []
num2 = list([])

print(f'nums id: {id(nums)}')
print("*"*20)
print(f'num2 id: {id(num2)}')
'''
nums id: 140592714551624
********************
num2 id: 140592711883720
'''

#-------------------------------------------------------
# list() - argument는 iterable 타입(반복이 가능한 데이터 타입) & sequence(인덱스가 있는 데이터 타입) 만 
	- 리스트, 튜플, 딕셔너리 등등 반복이 가능한 데이터 타입만 가능
	- 단일 변수인 int, float 등은 대입 불가능

datas = list(7)		# 불가능

datas = list( range(1,10) )	# [1, 2, 3, 4, 5, 6, 7, 8, 9]
datas = list( {1:'a', 2:'b'} )	# [1, 2]
						# 딕셔너리는 '키'가 메인이기 때문에 키만 리스트로!


#-----------------------------------------------------------------
# Tuple 데이터 자료형
# - 다양한 타입의 여러 데이터 저장 타입
# - list과 비슷 but only read
# - 수정&삭제&추가 불가!!
# - 형식
#   (데1, 데2, ..., 데n)
#    데1, 데2, ..., 데n
#   (데1,) or 데1       -> 1개만 가지는 튜플일 경우, ',' 꼭 표시!

# - list & tuple로 서로 타입캐스팅(형변환)을 통해 수정&삭제&추가 가능
#-----------------------------------------------------------------


#-----------------------------------------------------------------
# Tuple 데이터 자료형
# - 내장함수: len(), max(), min(), sum(), sorted()
# - 연산자:     덧셈,곱셈,멤버연산자
#-----------------------------------------------------------------

# 연산자 ---------------------------------------------------------

# 덧셈  -> 하나의 튜플로 생성 (같은 튜플끼리만!)
# 곱셈: tuple * int -> int만큼 반복해서 하나의 튜플로

#-----------------------------------------------------------------
# 내장함수 range()
# - 숫자 범위를 생성하는 내장함수
# - 형식: range(시작숫자, 끝숫자+1, 간격)   -> int만 가능
#       +) range(끝숫자+1) -> 0~끝숫자 1씩 증가
#-----------------------------------------------------------------


# [실습]-----------------------------------------------------
# 1.0 ~ 10.0 사이 숫자 저장
# list 변수 전체를 float(list)는 불가능
# map(float, list)로 실수화

datas = list( map( float, range(1,11) ) )
print(datas)
'''
[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
'''

# 1,000,000 표현

a=1_000_000

print(f"{a:,}")
print(f"{:,}".format(a))
print(format(a, 'd'))




















	


